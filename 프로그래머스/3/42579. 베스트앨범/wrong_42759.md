---

### 문제점 및 수정사항

1. **장르별 총 재생횟수 정렬 기준 오류**

   * 현재 정렬 람다에서

     ```cpp
     if (a.first == b.first)
         return a.second < b.second;
     return a.first > b.first;
     ```

     는 장르 이름(a.first, b.first)으로 비교하고 있음.
     총 재생횟수 기준 내림차순 정렬이어야 하므로, `a.second`와 `b.second`를 기준으로 정렬해야 합니다.

2. **`multimap<int, int, greater<int>>` 의 활용 문제**

   * multimap에 `(play, index)`를 넣고, 내림차순 정렬이 되게 했는데, `multimap`은 키 기준 정렬이지만 동점인 경우 index 오름차순이 보장되지 않습니다.
   * 또한 `multimap`을 순회할 때, 재생횟수 같은 경우가 중복되면 인덱스 기준 정렬이 안 되어 문제 발생 가능.

3. **곡 선택 로직 문제**

   * for문으로 `genres_play[gen.first]`의 모든 곡을 돌면서 `song_count`만큼만 넣고 있는데, `multimap`의 순회 순서는 키 기준 정렬이지만 위에서 지적한대로 인덱스 오름차순은 보장 안 됨.
   * `multimap` 대신 vector를 사용하고, 명확하게 정렬해서 곡 선택하는 것이 안정적임.

---

### 개선 코드 구조 제안 (C++ 기준)

* 장르별 재생횟수 누적은 `unordered_map<string,int>`
* 장르별 곡 목록은 `unordered_map<string, vector<pair<int,int>>>` (play, idx)
* 장르별 재생횟수 기준 내림차순 정렬
* 각 장르 내에서 재생횟수 내림차순, 인덱스 오름차순 정렬 후 2개 선택

---

### 수정된 코드 예시

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> solution(vector<string> genres, vector<int> plays) {
    unordered_map<string, int> genre_play_count;
    unordered_map<string, vector<pair<int, int>>> genre_songs;

    for (int i = 0; i < genres.size(); i++) {
        genre_play_count[genres[i]] += plays[i];
        genre_songs[genres[i]].emplace_back(plays[i], i);
    }

    // 장르별 총 재생횟수 내림차순 정렬
    vector<pair<string, int>> genre_order(genre_play_count.begin(), genre_play_count.end());
    sort(genre_order.begin(), genre_order.end(),
        [](const pair<string, int>& a, const pair<string, int>& b) {
            return a.second > b.second;
        });

    vector<int> answer;
    for (auto& genre : genre_order) {
        // 각 장르 내 곡 재생횟수 내림차순, 인덱스 오름차순 정렬
        auto& songs = genre_songs[genre.first];
        sort(songs.begin(), songs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first == b.first) return a.second < b.second;
            return a.first > b.first;
        });

        int count = 0;
        for (auto& song : songs) {
            if (count >= 2) break;
            answer.push_back(song.second);
            count++;
        }
    }

    return answer;
}
```

---

### 요약

* **정렬 기준이 가장 중요**: 장르별 총 재생횟수 기준 내림차순, 곡별 재생횟수 내림차순 + 고유번호 오름차순
* `multimap`보다 `vector + sort`가 명확하고 디버깅도 용이함
* 람다 내부에서 비교 기준이 잘못된 점 수정 필요
