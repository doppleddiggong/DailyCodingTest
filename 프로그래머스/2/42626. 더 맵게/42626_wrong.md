# 문제 개요

* 스코빌 지수 배열 `scoville`과 목표 스코빌 지수 `K`가 주어짐
* 가장 맵지 않은 두 음식을 섞어 새 스코빌 지수를 만든다:
  `newScoville = least + secondLeast * 2`
* 모든 음식의 스코빌 지수가 `K` 이상이 될 때까지 반복
* 최소 섞은 횟수 반환, 불가능하면 -1 반환

---

# 주요 오답 유형 및 원인 분석

| 번호 | 오답 유형                            | 원인                                              | 해결법                                                             |
| -- | -------------------------------- | ----------------------------------------------- | --------------------------------------------------------------- |
| 1  | `multiset` 또는 `vector`로 직접 정렬 반복 | 매번 정렬 비용이 크다 (`O(N log N)`) → 시간 초과             | 최소 힙(`priority_queue` + `greater<int>`) 사용해 `O(log N)` 삽입/삭제 유지 |
| 2  | 두 번째 최소값이 없는 상태에서 꺼내기 시도         | 남은 원소가 1개일 때도 꺼내려 시도해 런타임 오류 발생                 | `pq.size() >= 2` 조건 확인 필수                                       |
| 3  | 반복문 종료 조건 오류                     | 조건을 `while(pq.top() <= K)` 등으로 잘못 설정하면 무한 루프 발생 | 정확히 `while (!pq.empty() && pq.top() < K)` 및 크기 체크 병행            |
| 4  | 섞은 횟수 초기값 설정 오류                  | 횟수를 미리 1로 설정하거나 잘못 초기화함                         | `answer = 0`부터 시작하고 섞을 때마다 증가                                   |
| 5  | 섞기 후 새 스코빌 값 삽입 누락 또는 잘못 계산      | 새 값 `value + next_value * 2` 계산 실수 또는 삽입 누락     | 계산식 및 `pq.push()` 호출 꼼꼼히 확인                                     |
| 6  | 불가능할 때 -1 반환 누락                  | 모든 스코빌 지수가 `K` 이상이 되지 않을 때 반환 안 함               | 반복문 종료 후 `pq.top() < K`면 `-1` 반환 처리                             |
| 7  | 입출력 및 변수 타입 오류                   | `int` 범위 초과 가능성 간과 (드물지만)                       | 문제 범위 내에서는 `int` 충분하나, 큰 수면 `long long` 고려                      |

---

# 개선 및 주의 사항

* **최소 힙 구조 사용을 강력 권장**
  `std::priority_queue<int, std::vector<int>, std::greater<int>> pq;`

* **큐가 비었는지와 크기 체크는 필수**
  최소 2개 이상의 요소가 있어야 섞기 가능

* **불가능한 상황 대비**
  모든 조합을 시도했는데도 목표 미달 시 `-1` 반환

* **예외 케이스 테스트**

  * 모두 이미 `K` 이상일 때 (답은 0)
  * 배열 크기 1일 때 `K` 이상/미만
  * 큰 수와 작은 수 혼재

---

# 참고: 올바른 해법 코드 구조

```cpp
std::priority_queue<int, std::vector<int>, std::greater<int>> pq(scoville.begin(), scoville.end());
int answer = 0;

while (pq.size() > 1 && pq.top() < K) {
    int first = pq.top(); pq.pop();
    int second = pq.top(); pq.pop();
    pq.push(first + second * 2);
    ++answer;
}

return (pq.top() >= K) ? answer : -1;
```

---

필요하면 오답별 코드 샘플과 성능 차이도 추가 설명 가능합니다.
