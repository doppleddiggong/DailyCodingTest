# 📝 오답노트 – 프로그래머스 133502 햄버거 만들기

## 1. 내가 사용한 접근
- **아이디어**
  - `ingredient` 벡터에서 `1 2 3 1` 패턴을 순차적으로 탐색한다.
  - 발견하면 `erase`로 해당 구간을 삭제하고 다시 탐색한다.

- **구현 흐름**
  1. `find_it`로 패턴 매칭 포인터 이동.
  2. `begin_pos`로 패턴 시작 위치 기억.
  3. 패턴 완성 시 `erase`로 재료 삭제.
  4. 재료가 줄어들 때까지 반복.

---

## 2. 문제점
### (1) 시간 복잡도
- `erase`가 **O(n)** → 패턴이 많이 나오면 **O(n²)** 이상으로 악화.
- 입력 크기가 100만일 때 시간 초과 발생.

### (2) 인덱스 꼬임
- `erase` 후 뒤 요소들이 앞으로 당겨지면서 인덱스가 변함.
- `begin_pos` 이후 로직이 깨질 수 있음.

### (3) 오버랩 패턴 처리 실패
- `1231231` 같이 겹치는 패턴은 안정적으로 처리되지 않음.

---

## 3. 올바른 해결법
### 아이디어
- 스택(또는 동적 배열)을 사용해 재료를 하나씩 쌓는다.
- 최근 4개가 `1 2 3 1`이면 pop으로 제거한다.

### 코드
```cpp
int solution(vector<int> ingredient) {
    int answer = 0;
    vector<int> st;

    for (int ing : ingredient) {
        st.push_back(ing);

        if (st.size() >= 4) {
            if (st[st.size()-4] == 1 &&
                st[st.size()-3] == 2 &&
                st[st.size()-2] == 3 &&
                st[st.size()-1] == 1) {
                answer++;
                st.resize(st.size()-4);
            }
        }
    }

    return answer;
}
```
- 시간복잡도: **O(n)**
- 공간복잡도: **O(n)**
- 인덱스 꼬임 없음, 중첩 패턴도 처리 가능

---

## 4. 내 접근 유지하면서 개선한 버전
- `erase` 대신 새 컨테이너에 누적 후 조건 맞으면 제거

```cpp
int solution(vector<int> ingredient) {
    int answer = 0;
    vector<int> next;

    for (int ing : ingredient) {
        next.push_back(ing);

        if (next.size() >= 4) {
            int sz = next.size();
            if (next[sz-4] == 1 &&
                next[sz-3] == 2 &&
                next[sz-2] == 3 &&
                next[sz-1] == 1) {
                answer++;
                next.resize(sz-4);
            }
        }
    }

    return answer;
}
```

## 5. 배운 점
- erase는 중간 삭제가 많은 문제에서 비효율적이다.
- 패턴 탐지는 실시간 누적 구조(스택/큐) 가 훨씬 안정적이다.
- 겹치는 패턴은 “실시간 쌓기 → 조건 충족 시 제거” 로 해결 가능하다.
- O(n²) vs O(n) 차이가 문제의 성패를 결정한다.
